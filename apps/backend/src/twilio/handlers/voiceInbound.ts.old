import { Request, Response } from 'express';
import { TwilioVoicePayload } from '../utils/twilioTypes';
import { logger } from '../../utils/logger';
import { prisma } from '../../db';
import { findOrCreateCustomer } from '../../modules/customer/service';
import { findOrCreateConversation, addMessage } from '../../modules/conversation/service';
import { sendSMS } from '../client';
import { MessageDirection, MessageType } from '@prisma/client';
import { twilioToIntent } from '../../../../../integration/adapters/twilioToIntent.adapter';
import { inboundPipeline } from '../../../../../integration/pipelines/inbound.pipeline';
import { automationToBackend } from '../../../../../integration/adapters/automationToBackend.adapter';
import { lyraToSms } from '../../../../../integration/bridges/lyraToSms.bridge';
import { memoryPull } from '../../../../../integration/memory/memory.pull';
import { memoryMerge } from '../../../../../integration/memory/memory.merge';
import { memoryPush } from '../../../../../integration/memory/memory.push';
import { IntentSchema } from '../../../../../integration/validators/intent.validator';
import { AutomationSchema } from '../../../../../integration/validators/automation.validator';
import { sentinelGuard } from '../../../../../integration/sentinel/sentinel.guard';

/**
 * Handle inbound voice calls - AI Handoff Gateway
 * Responds with TwiML, then triggers async SMS AI handoff
 * FULLY INSTRUMENTED FOR PIPELINE DEBUGGING
 */
export async function handleInboundVoice(req: Request, res: Response): Promise<void> {
  try {
    const payload: TwilioVoicePayload = req.body;

    logger.info('üìû [VOICE INBOUND] Received inbound voice call', {
      from: payload.From,
      to: payload.To,
      callSid: payload.CallSid,
    });

    // Return TwiML response immediately to Twilio
    const twiml = `<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Say>Thanks for calling. Our assistant will text you now.</Say>
  <Hangup/>
</Response>`;

    res.type('text/xml');
    res.send(twiml);
    logger.info('‚úÖ [VOICE INBOUND] TwiML response sent to Twilio');

    // Continue async processing after TwiML sent
    setImmediate(async () => {
      try {
        logger.info('üîÑ [VOICE INBOUND] Starting async voice handoff processing...');

        // Find which client this number belongs to
        const client = await prisma.client.findFirst({
          where: { phoneNumber: payload.To },
        });

        if (!client) {
          logger.warn('‚ö†Ô∏è  [VOICE INBOUND] No client found for phone number', {
            phoneNumber: payload.To,
          });
          return;
        }

        logger.info('‚úÖ [VOICE INBOUND] Client found', {
          clientId: client.id,
          businessName: client.businessName,
        });

        // 1. Find or create customer
        const customer = await findOrCreateCustomer(client.id, payload.From);
        logger.info('‚úÖ [VOICE INBOUND] Customer resolved', {
          customerId: customer.id,
          phone: customer.phone,
        });

        // 2. Find or create conversation thread
        const conversation = await findOrCreateConversation(client.id, customer.id);
        logger.info('‚úÖ [VOICE INBOUND] Conversation resolved', {
          conversationId: conversation.id,
        });

        // 3. Log the call event as system message
        await addMessage({
          conversationId: conversation.id,
          clientId: client.id,
          customerId: customer.id,
          direction: MessageDirection.SYSTEM,
          type: MessageType.CALL,
          body: `Inbound call from ${payload.From}`,
          metadata: {
            callSid: payload.CallSid,
          },
        });
        logger.info('‚úÖ [VOICE INBOUND] Call event logged to DB');

        // 4. Build synthetic SMS payload for call handoff
        logger.info('üîÑ [VOICE INBOUND] Building synthetic SMS payload...');
        const syntheticSmsPayload = {
          Body: 'Call initiated ‚Äî start SMS flow.',
          From: payload.From,
          To: payload.To,
          MessageSid: `CALL_${payload.CallSid}`,
          AccountSid: payload.AccountSid || '',
          MessagingServiceSid: null,
          NumMedia: '0',
          NumSegments: '1',
          SmsMessageSid: `CALL_${payload.CallSid}`,
          SmsSid: `CALL_${payload.CallSid}`,
          SmsStatus: 'received',
          ApiVersion: payload.ApiVersion || '2010-04-01',
        };
        logger.info('‚úÖ [VOICE INBOUND] Synthetic SMS payload created');

        // 5. Convert to IntentObject (DIAL ADAPTER)
        logger.info('üîÑ [DIAL ADAPTER] Converting synthetic payload to IntentObject...');
        const intent = await twilioToIntent(syntheticSmsPayload);
        const validatedIntent = IntentSchema.parse(intent);
        logger.info('‚úÖ [DIAL ADAPTER] IntentObject created and validated', {
          intentObject: JSON.stringify(validatedIntent, null, 2),
        });

        // 6. Sentinel guard - inbound
        logger.info('üõ°Ô∏è  [SENTINEL] Running inbound guard on IntentObject...');
        const inboundGuard = await sentinelGuard({
          content: validatedIntent.raw_message,
          metadata: validatedIntent.metadata,
        });

        if (!inboundGuard.allowed) {
          logger.warn('‚ùå [SENTINEL] Voice handoff intent blocked by Sentinel', {
            reason: inboundGuard.reason,
            anomalies: inboundGuard.anomalies,
          });

          const fallbackMessage = "We'll get back to you shortly.";
          const fallbackSid = await sendSMS(payload.From, payload.To, fallbackMessage);

          await addMessage({
            conversationId: conversation.id,
            clientId: client.id,
            customerId: customer.id,
            direction: MessageDirection.OUTBOUND,
            type: MessageType.SMS,
            body: fallbackMessage,
            twilioSid: fallbackSid,
          });

          return;
        }
        logger.info('‚úÖ [SENTINEL] Inbound guard passed');

        // 7. Pull memory from DB (VAULT)
        logger.info('üóÑÔ∏è  [VAULT] Pulling memory for customer...');
        const memory = await memoryPull({ customer_number: payload.From });
        if (memory) {
          logger.info('‚úÖ [VAULT] Memory pulled successfully', {
            memoryObject: JSON.stringify(memory, null, 2),
          });
        } else {
          logger.info('‚ÑπÔ∏è  [VAULT] No existing memory found for customer');
        }

        // 8. Merge memory with call event
        if (memory) {
          logger.info('üîÑ [VAULT] Merging call event into memory...');
          const updatedMemory = await memoryMerge(memory, {
            history: [
              {
                timestamp: new Date().toISOString(),
                event_type: 'inbound_call',
                notes: `Call from ${payload.From} - ${payload.CallSid}`,
              },
            ],
            last_interaction: new Date().toISOString(),
          });
          logger.info('‚úÖ [VAULT] Memory merged', {
            memoryObject: JSON.stringify(updatedMemory, null, 2),
          });

          logger.info('üîÑ [VAULT] Pushing updated memory to DB...');
          await memoryPush(updatedMemory);
          logger.info('‚úÖ [VAULT] Memory pushed successfully');
        }

        // 9. Send into inbound pipeline (FLOW ‚Üí RUNE)
        logger.info('üöÄ [PIPELINE] Starting inbound pipeline (FLOW ‚Üí RUNE)...');
        logger.info('üîÑ [FLOW] Calling FLOW agent with IntentObject...');

        const automation = await inboundPipeline(validatedIntent);

        logger.info('‚úÖ [RUNE] AutomationObject received from pipeline');
        const validatedAutomation = AutomationSchema.parse(automation);
        logger.info('‚úÖ [RUNE] AutomationObject validated', {
          automationObject: JSON.stringify(validatedAutomation, null, 2),
        });

        // 10. Sentinel guard - outbound automation
        logger.info('üõ°Ô∏è  [SENTINEL] Running automation guard on AutomationObject...');
        const automationGuard = await sentinelGuard({
          content: validatedAutomation.reasoning,
          metadata: { action: validatedAutomation.action },
        });

        if (!automationGuard.allowed) {
          logger.warn('‚ùå [SENTINEL] Voice handoff automation blocked by Sentinel', {
            reason: automationGuard.reason,
            anomalies: automationGuard.anomalies,
          });

          const fallbackMessage = "We'll get back to you shortly.";
          const fallbackSid = await sendSMS(payload.From, payload.To, fallbackMessage);

          await addMessage({
            conversationId: conversation.id,
            clientId: client.id,
            customerId: customer.id,
            direction: MessageDirection.OUTBOUND,
            type: MessageType.SMS,
            body: fallbackMessage,
            twilioSid: fallbackSid,
          });

          return;
        }
        logger.info('‚úÖ [SENTINEL] Automation guard passed');

        // 11. Convert automation output ‚Üí backend actions (DISPATCH)
        logger.info('üîÑ [DISPATCH] Converting AutomationObject to backend action...');
        const backendAction = await automationToBackend(validatedAutomation);

        logger.info('‚úÖ [DISPATCH] Backend action generated', {
          type: backendAction.type,
          targets: backendAction.targets,
          backendAction: JSON.stringify(backendAction, null, 2),
        });

        // 12. Generate response message (LYRA)
        logger.info('üîÑ [LYRA] Generating response message...');
        let responseMessage = 'Thanks for calling! How can we help you today?';

        if (validatedAutomation.action === 'send_booking_link') {
          responseMessage =
            'Thanks for calling! Here is your booking link: https://booking.jobrun.app';
        } else if (validatedAutomation.action === 'send_quote_message') {
          responseMessage =
            'Thanks for calling! We will prepare an estimate and text you shortly.';
        } else if (validatedAutomation.action === 'ask_for_more_info') {
          responseMessage = 'Thanks for calling! What service can we help you with?';
        }

        logger.info('‚úÖ [LYRA] Response message generated', {
          responseMessage,
        });

        // 13. Sentinel guard - outbound message
        logger.info('üõ°Ô∏è  [SENTINEL] Running outbound message guard...');
        const messageGuard = await sentinelGuard({
          content: responseMessage,
          metadata: { customer_number: payload.From },
        });

        if (!messageGuard.allowed) {
          logger.warn('‚ùå [SENTINEL] Voice handoff outbound message blocked', {
            reason: messageGuard.reason,
          });

          responseMessage = "We'll get back to you shortly.";
        }
        logger.info('‚úÖ [SENTINEL] Outbound message guard passed');

        // 14. Send SMS through existing Twilio wrapper
        logger.info('üì§ [TWILIO] Sending SMS to customer...');
        const twilioSid = await sendSMS(payload.From, payload.To, responseMessage);
        logger.info('‚úÖ [TWILIO] SMS sent successfully', {
          twilioSid,
        });

        // 15. Save outbound message
        await addMessage({
          conversationId: conversation.id,
          clientId: client.id,
          customerId: customer.id,
          direction: MessageDirection.OUTBOUND,
          type: MessageType.SMS,
          body: responseMessage,
          twilioSid,
        });
        logger.info('‚úÖ [DB] Outbound message saved');

        // 16. Final memory update (VAULT)
        if (memory) {
          logger.info('üîÑ [VAULT] Merging outbound SMS event into memory...');
          const finalMemory = await memoryMerge(memory, {
            history: [
              {
                timestamp: new Date().toISOString(),
                event_type: 'outbound_sms_after_call',
                notes: responseMessage,
              },
            ],
            last_interaction: new Date().toISOString(),
          });
          logger.info('‚úÖ [VAULT] Final memory merged', {
            memoryObject: JSON.stringify(finalMemory, null, 2),
          });

          logger.info('üîÑ [VAULT] Pushing final memory to DB...');
          await memoryPush(finalMemory);
          logger.info('‚úÖ [VAULT] Final memory pushed successfully');
        }

        logger.info('üéâ [VOICE INBOUND] Pipeline completed successfully', {
          customerId: customer.id,
          conversationId: conversation.id,
          callSid: payload.CallSid,
          intent: validatedIntent.intent,
          automation: validatedAutomation.action,
          summary: {
            intent: validatedIntent.intent,
            action: validatedAutomation.action,
            responseMessage,
          },
        });
      } catch (asyncError) {
        logger.error('‚ùå [VOICE INBOUND] Async pipeline error', {
          error: asyncError instanceof Error ? asyncError.message : String(asyncError),
          stack: asyncError instanceof Error ? asyncError.stack : undefined,
        });

        try {
          const fallbackMessage =
            "Sorry ‚Äî we're having trouble right now. We'll text you shortly.";
          await sendSMS(payload.From, payload.To, fallbackMessage);
          logger.info('‚úÖ [VOICE INBOUND] Fallback message sent');
        } catch (fallbackError) {
          logger.error('‚ùå [VOICE INBOUND] Failed to send fallback SMS', {
            error: fallbackError instanceof Error ? fallbackError.message : String(fallbackError),
          });
        }
      }
    });
  } catch (error) {
    logger.error('‚ùå [VOICE INBOUND] Handler error', {
      error: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined,
    });
    res.status(500).send('Internal server error');
  }
}
